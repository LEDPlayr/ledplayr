import type { Client, Options as Options2, TDataShape } from "./client";
import type {
  DelButtonData,
  DelButtonErrors,
  DelButtonResponses,
  DelMeshData,
  DelMeshErrors,
  DelMeshResponses,
  DelPlaylistData,
  DelPlaylistErrors,
  DelPlaylistResponses,
  DelSceneData,
  DelSceneErrors,
  DelSceneResponses,
  DelScheduleData,
  DelScheduleErrors,
  DelScheduleResponses,
  DelSequenceData,
  DelSequenceErrors,
  DelSequenceResponses,
  DownloadMeshData,
  DownloadMeshErrors,
  DownloadMeshResponses,
  FileUploadData,
  FileUploadErrors,
  FileUploadResponses,
  FppCommandData,
  FppCommandErrors,
  FppCommandResponses,
  GetButtonData,
  GetButtonErrors,
  GetButtonResponses,
  GetDisplayData,
  GetDisplayErrors,
  GetDisplayResponses,
  GetLogData,
  GetLogErrors,
  GetLogResponses,
  GetOutputsData,
  GetOutputsErrors,
  GetOutputsResponses,
  GetPlaylistData,
  GetPlaylistErrors,
  GetPlaylistResponses,
  GetSceneData,
  GetSceneErrors,
  GetSceneResponses,
  GetScheduleData,
  GetScheduleErrors,
  GetScheduleResponses,
  GetSequenceData,
  GetSequenceErrors,
  GetSequenceMetaData,
  GetSequenceMetaErrors,
  GetSequenceMetaResponses,
  GetSequenceResponses,
  GetStatusData,
  GetStatusErrors,
  GetStatusResponses,
  GetTestPatternData,
  GetTestPatternErrors,
  GetTestPatternResponses,
  ListButtonsData,
  ListButtonsErrors,
  ListButtonsResponses,
  ListLogsData,
  ListLogsErrors,
  ListLogsResponses,
  ListMeshesData,
  ListMeshesErrors,
  ListMeshesResponses,
  ListModelsData,
  ListModelsErrors,
  ListModelsResponses,
  ListPlaylistsData,
  ListPlaylistsErrors,
  ListPlaylistsNumberedData,
  ListPlaylistsNumberedErrors,
  ListPlaylistsNumberedResponses,
  ListPlaylistsResponses,
  ListScenesData,
  ListScenesErrors,
  ListScenesResponses,
  ListSchedulesData,
  ListSchedulesErrors,
  ListSchedulesResponses,
  ListSequencesData,
  ListSequencesErrors,
  ListSequencesResponses,
  NewButtonData,
  NewButtonErrors,
  NewButtonResponses,
  NewMeshData,
  NewMeshErrors,
  NewMeshResponses,
  NewPlaylistData,
  NewPlaylistErrors,
  NewPlaylistResponses,
  NewSceneData,
  NewSceneErrors,
  NewSceneResponses,
  NewScheduleData,
  NewScheduleErrors,
  NewScheduleResponses,
  RunTestData,
  RunTestErrors,
  RunTestResponses,
  StartSchedulerData,
  StartSchedulerErrors,
  StartSchedulerResponses,
  StopData,
  StopErrors,
  StopResponses,
  SystemInfoData,
  SystemInfoResponses,
  UpdateButtonData,
  UpdateButtonErrors,
  UpdateButtonResponses,
  UpdateMeshData,
  UpdateMeshErrors,
  UpdateMeshResponses,
  UpdatePlaylistData,
  UpdatePlaylistErrors,
  UpdatePlaylistResponses,
  UpdateSceneData,
  UpdateSceneErrors,
  UpdateSceneResponses,
  UpdateScheduleData,
  UpdateScheduleErrors,
  UpdateScheduleResponses,
  UploadDisplayData,
  UploadDisplayErrors,
  UploadDisplayResponses,
  UploadModelsData,
  UploadModelsErrors,
  UploadModelsResponses,
  UploadOutputsData,
  UploadOutputsErrors,
  UploadOutputsResponses,
} from "./types.gen";

import { formDataBodySerializer } from "./client";
import { client } from "./client.gen";

// This file is auto-generated by @hey-api/openapi-ts

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client;
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>;
};

/**
 * New button
 *
 * Create a new button
 */
export const newButton = <ThrowOnError extends boolean = false>(
  options: Options<NewButtonData, ThrowOnError>,
) => {
  return (options.client ?? client).post<NewButtonResponses, NewButtonErrors, ThrowOnError>({
    url: "/api/button",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Delete a button
 *
 * Delete the given button
 */
export const delButton = <ThrowOnError extends boolean = false>(
  options: Options<DelButtonData, ThrowOnError>,
) => {
  return (options.client ?? client).delete<DelButtonResponses, DelButtonErrors, ThrowOnError>({
    url: "/api/button/{button}",
    ...options,
  });
};

/**
 * Get a button
 *
 * Get a single button
 */
export const getButton = <ThrowOnError extends boolean = false>(
  options: Options<GetButtonData, ThrowOnError>,
) => {
  return (options.client ?? client).get<GetButtonResponses, GetButtonErrors, ThrowOnError>({
    url: "/api/button/{button}",
    ...options,
  });
};

/**
 * Update a button
 *
 * Update the given button
 */
export const updateButton = <ThrowOnError extends boolean = false>(
  options: Options<UpdateButtonData, ThrowOnError>,
) => {
  return (options.client ?? client).put<
    UpdateButtonResponses,
    UpdateButtonErrors,
    ThrowOnError
  >({
    url: "/api/button/{button}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * List all buttons
 *
 * List all remote buttons
 */
export const listButtons = <ThrowOnError extends boolean = false>(
  options?: Options<ListButtonsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<ListButtonsResponses, ListButtonsErrors, ThrowOnError>(
    {
      url: "/api/buttons",
      ...options,
    },
  );
};

/**
 * Retrieve outputs.json
 *
 * Download the outputs in JSON format
 */
export const getOutputs = <ThrowOnError extends boolean = false>(
  options?: Options<GetOutputsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<GetOutputsResponses, GetOutputsErrors, ThrowOnError>({
    url: "/api/channel/output/universeOutputs",
    ...options,
  });
};

/**
 * Upload outputs.json
 *
 * Upload the outputs in JSON format
 */
export const uploadOutputs = <ThrowOnError extends boolean = false>(
  options: Options<UploadOutputsData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    UploadOutputsResponses,
    UploadOutputsErrors,
    ThrowOnError
  >({
    url: "/api/channel/output/universeOutputs",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Retrieve VirtualDisplayMap
 *
 * Download the VirtualDisplayMap
 */
export const getDisplay = <ThrowOnError extends boolean = false>(
  options?: Options<GetDisplayData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<GetDisplayResponses, GetDisplayErrors, ThrowOnError>({
    url: "/api/configfile/virtualdisplaymap",
    ...options,
  });
};

/**
 * Upload VirtualDisplayMap
 *
 * Upload the VirtualDisplayMap
 */
export const uploadDisplay = <ThrowOnError extends boolean = false>(
  options: Options<UploadDisplayData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    UploadDisplayResponses,
    UploadDisplayErrors,
    ThrowOnError
  >({
    bodySerializer: null,
    url: "/api/configfile/virtualdisplaymap",
    ...options,
    headers: {
      "Content-Type": "application/octet-stream",
      ...options.headers,
    },
  });
};

/**
 * Get a specific log
 */
export const getLog = <ThrowOnError extends boolean = false>(
  options: Options<GetLogData, ThrowOnError>,
) => {
  return (options.client ?? client).get<GetLogResponses, GetLogErrors, ThrowOnError>({
    url: "/api/log/{name}",
    ...options,
  });
};

/**
 * Get log filenames
 */
export const listLogs = <ThrowOnError extends boolean = false>(
  options?: Options<ListLogsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<ListLogsResponses, ListLogsErrors, ThrowOnError>({
    url: "/api/logs",
    ...options,
  });
};

/**
 * New mesh
 *
 * Create a new mesh
 */
export const newMesh = <ThrowOnError extends boolean = false>(
  options: Options<NewMeshData, ThrowOnError>,
) => {
  return (options.client ?? client).post<NewMeshResponses, NewMeshErrors, ThrowOnError>({
    url: "/api/mesh",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Delete a mesh
 *
 * Delete the given mesh
 */
export const delMesh = <ThrowOnError extends boolean = false>(
  options: Options<DelMeshData, ThrowOnError>,
) => {
  return (options.client ?? client).delete<DelMeshResponses, DelMeshErrors, ThrowOnError>({
    url: "/api/mesh/{mesh}",
    ...options,
  });
};

/**
 * Get a 3D mesh
 *
 * Download a 3D mesh for the virtual display
 */
export const downloadMesh = <ThrowOnError extends boolean = false>(
  options: Options<DownloadMeshData, ThrowOnError>,
) => {
  return (options.client ?? client).get<
    DownloadMeshResponses,
    DownloadMeshErrors,
    ThrowOnError
  >({
    url: "/api/mesh/{mesh}",
    ...options,
  });
};

/**
 * Update a mesh
 *
 * Create or update the given mesh
 */
export const updateMesh = <ThrowOnError extends boolean = false>(
  options: Options<UpdateMeshData, ThrowOnError>,
) => {
  return (options.client ?? client).put<UpdateMeshResponses, UpdateMeshErrors, ThrowOnError>({
    url: "/api/mesh/{mesh}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * List all meshes
 *
 * List all 3D meshes
 */
export const listMeshes = <ThrowOnError extends boolean = false>(
  options?: Options<ListMeshesData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<ListMeshesResponses, ListMeshesErrors, ThrowOnError>({
    url: "/api/meshes",
    ...options,
  });
};

/**
 * Retrieve models.json
 *
 * Download the models in JSON format
 */
export const listModels = <ThrowOnError extends boolean = false>(
  options?: Options<ListModelsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<ListModelsResponses, ListModelsErrors, ThrowOnError>({
    url: "/api/models",
    ...options,
  });
};

/**
 * Upload models.json
 *
 * Upload the models in JSON format
 */
export const uploadModels = <ThrowOnError extends boolean = false>(
  options: Options<UploadModelsData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    UploadModelsResponses,
    UploadModelsErrors,
    ThrowOnError
  >({
    url: "/api/models",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get the player status
 */
export const getStatus = <ThrowOnError extends boolean = false>(
  options?: Options<GetStatusData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<GetStatusResponses, GetStatusErrors, ThrowOnError>({
    url: "/api/player",
    ...options,
  });
};

/**
 * Start the player scheduling
 */
export const startScheduler = <ThrowOnError extends boolean = false>(
  options?: Options<StartSchedulerData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    StartSchedulerResponses,
    StartSchedulerErrors,
    ThrowOnError
  >({
    url: "/api/player/schedule",
    ...options,
  });
};

/**
 * Stop the player
 */
export const stop = <ThrowOnError extends boolean = false>(
  options?: Options<StopData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<StopResponses, StopErrors, ThrowOnError>({
    url: "/api/player/stop",
    ...options,
  });
};

/**
 * Run LED test patterns
 */
export const runTest = <ThrowOnError extends boolean = false>(
  options: Options<RunTestData, ThrowOnError>,
) => {
  return (options.client ?? client).post<RunTestResponses, RunTestErrors, ThrowOnError>({
    url: "/api/player/test",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * New playlist
 *
 * Create a new playlist
 */
export const newPlaylist = <ThrowOnError extends boolean = false>(
  options: Options<NewPlaylistData, ThrowOnError>,
) => {
  return (options.client ?? client).post<NewPlaylistResponses, NewPlaylistErrors, ThrowOnError>(
    {
      url: "/api/playlist",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    },
  );
};

/**
 * Delete a playlist
 *
 * Delete the given playlist
 */
export const delPlaylist = <ThrowOnError extends boolean = false>(
  options: Options<DelPlaylistData, ThrowOnError>,
) => {
  return (options.client ?? client).delete<
    DelPlaylistResponses,
    DelPlaylistErrors,
    ThrowOnError
  >({
    url: "/api/playlist/{playlist}",
    ...options,
  });
};

/**
 * Get a playlist
 *
 * Read back a playlist
 */
export const getPlaylist = <ThrowOnError extends boolean = false>(
  options: Options<GetPlaylistData, ThrowOnError>,
) => {
  return (options.client ?? client).get<GetPlaylistResponses, GetPlaylistErrors, ThrowOnError>({
    url: "/api/playlist/{playlist}",
    ...options,
  });
};

/**
 * Update a playlist
 *
 * Create or update the given playlist
 */
export const updatePlaylist = <ThrowOnError extends boolean = false>(
  options: Options<UpdatePlaylistData, ThrowOnError>,
) => {
  return (options.client ?? client).put<
    UpdatePlaylistResponses,
    UpdatePlaylistErrors,
    ThrowOnError
  >({
    url: "/api/playlist/{playlist}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * List playlists
 *
 * List the name of all playlists
 */
export const listPlaylists = <ThrowOnError extends boolean = false>(
  options?: Options<ListPlaylistsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    ListPlaylistsResponses,
    ListPlaylistsErrors,
    ThrowOnError
  >({
    url: "/api/playlists",
    ...options,
  });
};

/**
 * List playlists with ID
 *
 * List the playlists with their ID
 */
export const listPlaylistsNumbered = <ThrowOnError extends boolean = false>(
  options?: Options<ListPlaylistsNumberedData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    ListPlaylistsNumberedResponses,
    ListPlaylistsNumberedErrors,
    ThrowOnError
  >({
    url: "/api/playlists/numbered",
    ...options,
  });
};

/**
 * New scene
 *
 * Create a new scene
 */
export const newScene = <ThrowOnError extends boolean = false>(
  options: Options<NewSceneData, ThrowOnError>,
) => {
  return (options.client ?? client).post<NewSceneResponses, NewSceneErrors, ThrowOnError>({
    url: "/api/scene",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Delete a scene
 *
 * Delete the given scene
 */
export const delScene = <ThrowOnError extends boolean = false>(
  options: Options<DelSceneData, ThrowOnError>,
) => {
  return (options.client ?? client).delete<DelSceneResponses, DelSceneErrors, ThrowOnError>({
    url: "/api/scene/{scene}",
    ...options,
  });
};

/**
 * List scenes
 *
 * List all scenes
 */
export const listScenes = <ThrowOnError extends boolean = false>(
  options?: Options<ListScenesData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<ListScenesResponses, ListScenesErrors, ThrowOnError>({
    url: "/api/scenes",
    ...options,
  });
};

/**
 * Get a scene
 *
 * Read a single scene
 */
export const getScene = <ThrowOnError extends boolean = false>(
  options: Options<GetSceneData, ThrowOnError>,
) => {
  return (options.client ?? client).get<GetSceneResponses, GetSceneErrors, ThrowOnError>({
    url: "/api/scenes/{scene}",
    ...options,
  });
};

/**
 * Update a scene
 *
 * Create or update the given scene
 */
export const updateScene = <ThrowOnError extends boolean = false>(
  options: Options<UpdateSceneData, ThrowOnError>,
) => {
  return (options.client ?? client).put<UpdateSceneResponses, UpdateSceneErrors, ThrowOnError>({
    url: "/api/scenes/{scene}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * New schedule
 *
 * Create a new schedule
 */
export const newSchedule = <ThrowOnError extends boolean = false>(
  options: Options<NewScheduleData, ThrowOnError>,
) => {
  return (options.client ?? client).post<NewScheduleResponses, NewScheduleErrors, ThrowOnError>(
    {
      url: "/api/schedule",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    },
  );
};

/**
 * Delete a schedule
 *
 * Delete the given schedule
 */
export const delSchedule = <ThrowOnError extends boolean = false>(
  options: Options<DelScheduleData, ThrowOnError>,
) => {
  return (options.client ?? client).delete<
    DelScheduleResponses,
    DelScheduleErrors,
    ThrowOnError
  >({
    url: "/api/schedule/{schedule}",
    ...options,
  });
};

/**
 * Get a schedule
 *
 * Read back a schedule
 */
export const getSchedule = <ThrowOnError extends boolean = false>(
  options: Options<GetScheduleData, ThrowOnError>,
) => {
  return (options.client ?? client).get<GetScheduleResponses, GetScheduleErrors, ThrowOnError>({
    url: "/api/schedule/{schedule}",
    ...options,
  });
};

/**
 * Update a schedule
 *
 * Create or update the given schedule
 */
export const updateSchedule = <ThrowOnError extends boolean = false>(
  options: Options<UpdateScheduleData, ThrowOnError>,
) => {
  return (options.client ?? client).put<
    UpdateScheduleResponses,
    UpdateScheduleErrors,
    ThrowOnError
  >({
    url: "/api/schedule/{schedule}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * List schedules
 *
 * List the name of all schedules
 */
export const listSchedules = <ThrowOnError extends boolean = false>(
  options?: Options<ListSchedulesData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    ListSchedulesResponses,
    ListSchedulesErrors,
    ThrowOnError
  >({
    url: "/api/schedules",
    ...options,
  });
};

/**
 * Delete a sequence
 *
 * Remove a sequence file
 */
export const delSequence = <ThrowOnError extends boolean = false>(
  options: Options<DelSequenceData, ThrowOnError>,
) => {
  return (options.client ?? client).delete<
    DelSequenceResponses,
    DelSequenceErrors,
    ThrowOnError
  >({
    url: "/api/sequence/{filename}",
    ...options,
  });
};

/**
 * Get a sequence
 *
 * Download a sequence file
 */
export const getSequence = <ThrowOnError extends boolean = false>(
  options: Options<GetSequenceData, ThrowOnError>,
) => {
  return (options.client ?? client).get<GetSequenceResponses, GetSequenceErrors, ThrowOnError>({
    url: "/api/sequence/{filename}",
    ...options,
  });
};

/**
 * Get a sequence's metadata
 *
 * Get the metadata belonging to a sequence
 */
export const getSequenceMeta = <ThrowOnError extends boolean = false>(
  options: Options<GetSequenceMetaData, ThrowOnError>,
) => {
  return (options.client ?? client).get<
    GetSequenceMetaResponses,
    GetSequenceMetaErrors,
    ThrowOnError
  >({
    url: "/api/sequence/{filename}/meta",
    ...options,
  });
};

/**
 * List all sequences
 *
 * List all sequence files
 */
export const listSequences = <ThrowOnError extends boolean = false>(
  options?: Options<ListSequencesData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    ListSequencesResponses,
    ListSequencesErrors,
    ThrowOnError
  >({
    url: "/api/sequences",
    ...options,
  });
};

/**
 * Get system info.
 *
 * Get the high-level system information. This endpoint is used
 * to simulate FPP and make us discoverable by other software such
 * as xLights. Some values are hard-coded to ensure compatibility.
 */
export const systemInfo = <ThrowOnError extends boolean = false>(
  options?: Options<SystemInfoData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<SystemInfoResponses, unknown, ThrowOnError>({
    url: "/api/system/info",
    ...options,
  });
};

/**
 * Get the pattern of LED colors for the given test
 */
export const getTestPattern = <ThrowOnError extends boolean = false>(
  options: Options<GetTestPatternData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    GetTestPatternResponses,
    GetTestPatternErrors,
    ThrowOnError
  >({
    url: "/api/test_pattern",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Upload a file
 *
 * Accepts fseq sequences or media files such as
 * images and videos. The uploaded file is automatically
 * sorted into the relevant upload directory so a call to
 * `moveFile` isn't required and will be ignore.
 */
export const fileUpload = <ThrowOnError extends boolean = false>(
  options: Options<FileUploadData, ThrowOnError>,
) => {
  return (options.client ?? client).post<FileUploadResponses, FileUploadErrors, ThrowOnError>({
    ...formDataBodySerializer,
    url: "/api/upload",
    ...options,
    headers: {
      "Content-Type": null,
      ...options.headers,
    },
  });
};

/**
 * Run an FPP Command
 *
 * This method isn't really implemented. The only command you
 * can issue is `moveFile` and all that really does is check
 * whether a file exists or not - it doesn't move it because
 * that's handled at upload time.
 */
export const fppCommand = <ThrowOnError extends boolean = false>(
  options: Options<FppCommandData, ThrowOnError>,
) => {
  return (options.client ?? client).get<FppCommandResponses, FppCommandErrors, ThrowOnError>({
    url: "/fppxml.php",
    ...options,
  });
};
